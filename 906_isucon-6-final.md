# ISUCON6 qualify

## Regulation
[opening-presentation](https://speakerdeck.com/kamikosan/isucon6-final)
[regulation](https://github.com/isucon/isucon6-final/blob/master/regulation.md)
[description-slide](https://speakerdeck.com/edvakf/isucon6ben-xuan-regiyuresiyonshuo-ming)

```
以下の事項を守ってください。違反した場合は失格とします。

参加者の作業対象サーバは主催者に与えられた5ノードのみとし、ベンチマーク負荷の処理の目的ではその他のいかなる計算機資源の使用も禁止する
データ変換等の目的についても、主催者から与えられた計算機以外のものを使用してはならない
外部のメトリクス計測サービスの使用のみ特例として許可するが、スコアを向上させるいかなる効果も持つものであってはならない
以上の条項に抵触しない範囲の作業は全てを認めます。ベンチマークが失敗を検出しない限りはスコアが認定されます。 しかし参加者の環境の破壊については主催者はいかなる救済も行いませんので、参加者の責任においてサーバ環境およびソフトウェアの変更を行ってください。
```

## Source
[isucon6-final](https://github.com/isucon/isucon6-final)

## Rule

```
基本スコアは以下のルールで算出されます。またPOSTリクエストについてはレスポンスが返った瞬間からそのリクエストの要求する更新内容が反映されている必要があります。

POSTは20点、GETは1点
/api/stream/room/:id は Server-Sent Events の仕様に従っていれば挙動を変えても構わない
streamはPOSTされた結果が2秒以内に到着すれば1点
減点は無い
レスポンスにエラーがあった場合、ベンチマーカーが送るリクエスト量が減るのでスコアが上がりにくくなる
クリティカルなエラーならFAILになる
```

## 問題の解説と講評
[officailsite](http://isucon.net/archives/48778066.html)


#### Docker

 > 本番環境で動いているアプリケーションを手元に持ってきて開発するのには非常に便利なのですが、ネットワークがNATなので、今回のようなTCPコネクションを捌き切る問題ではDockerを外したほうが良いという想定でした

 #### MySQl

 > トップページでは各roomにstroke_countをつけるためにN+1でCOUNTクエリを投げていましたが、roomsテーブルにstroke_countカラムを付けるなどで対策できたはずです。

TODO: 実装例

> pointsテーブルがかなり巨大ということがありましたが、はてなさんとの予行演習ではpointsテーブルを廃止してstrokesテーブルにテキストカラムでpointsを持たせると速くなるという予想外の最適化が見られました。

> トップページやroomのページにリクエストされるたびにCSRFトークンを挿入していましたが、現実のウェブアプリケーションではこういうことはしませんし、キャッシュストアに逃したほうが良いです。あるいはcookieにしてしまってそもそもサーバー内に保存しないという手もあります。

#### React
```
サーバーサイドレンダリングはめちゃくちゃCPUを使います。


今回のベンチマーカーは60秒で最大200回ぐらいしかPOSTしません（スループットが出ないと10回程度しかPOSTしません）ので、CSRFトークン以外の部分は生成済みHTMLをキャッシュしてしまうのが有効でしょう。

ただし、「キャッシュするならPOST時に削除必須」というスタンスで作りました。FastlyのようなキャッシュのインスタントパージがあるCDNが出てきて、キャッシュのインスタントパージができることを前提にウェブアプリケーションを設計することが増えてきているためです。

SVGに関してはReactを使っているとはいえ、 renderToStaticMarkup による出力なので、NodeJSを剥がして単純な文字列操作で出力するのは簡単でした。

SVG以外のHTMLについては難しいです。（トップページに関しては） data-react-id や data-react-checksum をきちんとつけなければ失格にしていました。これについては以下のような方針を考えていました。

NodeJSオンリーにする
> バックエンドのAPIとしてNodeJSの実装も用意していましたので、そちらとReactのフロントエンドをマージして、キャッシュの管理を柔軟にやる方針です。


> APIからReactを呼び出すようにするキャッシュの管理を含めて主要な部分をすべて慣れている言語で行い、React部分はレンダリングのためだけに使う方針です。

> POST時にHTMLをレンダリングして保存しておけば、GET時はNodeJSは不要になります。予選問題のisupamぐらいに「気にする必要のないマイクロサービス」にしてしまうことができたはずです。
この変更は server.jsx をちょっと書き換えるだけで可能です。

#### Server-Sent Events (SSE)

> /api/streams以下はServer-Sent Eventsの仕様に従っていれば挙動を変えてもかまわない
> POSTしたstrokeが2秒以内にstreamされたら1点

#### TLS

```
TLS終端のCPU負荷が問題になるはずです。ベンチマーカーがアクセスするIPアドレスが一つだけなので、TLS終端を5台に分散させるには、NATを使うなどの構成を考える必要があります。

このあたりは最適解が見えないのですが、ベンチマーカーではnginxのstreamでTCPのフォワードプロキシを実現することで最終的に65535コネクション以上を開くこともできるようになっていました。
```

